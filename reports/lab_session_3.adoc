= Network Security Class Lab Session 3
Stefano Zanella - 621796
A.Y. 2012-13

== Implementation Details
Here are the choices made where requested by the assignment or when no further
specification given:

* The assignment has been implemented in **Ruby** (version **2.0.0-p195**)
* To simplify the resulting codebase hosts have been modeled as classes, and
  communications over the network channel have been modeled with a `Channel`
  class that acts like a simple shared message storage. This allows to easily
  simulate message exchanging and eavesdropping.
* For the same reason, and to make the source code more readable, data
  concatenation has been modeled with hash maps. This in fact replaces
  specifying data chuncks' lengths in the protocol with specifying the keys at
  which data chuncks are accessible.
* Cryptographic primitives (ciphers, RNGs, etc.) are provided by Ruby's wrapper
  around the **OpenSSL** library and core language facilites. In detail:

  * RNG is provided by the built-in `Random` class
    (http://ruby-doc.org/core-2.0/Random.html[documentation]), a PRNG based
    on a _Mersenne twister_.
  * asymmetric public key algorithm is RSA (Ruby
    http://www.ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/PKey/RSA.html[documentation]),
    with **2048 bits** key length.
  * symmetric key cipher is **AES 256**, used when simulating communications
    between nodes.
  * message authentication/integrity protection is provided by class `OpenSSL::HMAC`, which accepts
    an available digest algorithm as a parameter. Selected cryptographic hash
    function for message authentication is **SHA512**, provided by class
    `OpenSSL::Digest::SHA512`
    (http://www.ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/Digest.html[documentation]).

* Since OpenSSL RSA works on strings, all hashes used for communication needed
  to be serialized before encryption. Ruby's built-in standard for
  serialization/deserialization is **YAML**
  (http://www.ruby-doc.org/stdlib-2.0/libdoc/yaml/rdoc/YAML.html[documentation]),
  which use is made transparent by encapsulation into class `NetSec::Node`.

== Protocol Implementation
Given protocol is implemented in `NetSec::KeyExchange#start!` method. +
Correctness is proven at the end by printing keys hold by **A** and **B**,
which are obviously the same in case the protocol works correctly.

To run the exchange, just type at the prompt, from inside the source folder:

[source,bash]
bin/key_agreement

The output should be something similar to:

[source,bash]
A has key: ["a2b85f3a7164c411d8ea5eb66affa741472eb59be787c3b3ea63b7816c868d39"]
B has key: ["a2b85f3a7164c411d8ea5eb66affa741472eb59be787c3b3ea63b7816c868d39"]

== Possible Flaws and Related Attacks
=== C Node Spoofing
While **C** makes use of asymmetric cryptography to exchange the key with
**A** and **B**, these last two does not the same when communicating with
**C**. This easily allows an attacker to spoof **C**'s identity (for example,
by DoSing it and routing requests to itself); once the attacker can
successfully impersonate **C** it has just to save the list of generated keys
and start eavesdropping from the communication channel. This way it can do
whatever it wants (from simply logging exchanged information to manipulation of
exchanged data), given no other security mechanisms are in place for a given
session (e.g. for message integrity).

== Attacks Implementation and Analysis
=== C Node Spoofing
To simulate spoofing of node C, a `NetSec::SpoofedC` subclass has been
introduced. Basically it acts the same way as its parent class, plus it
eavesdrop on the channel upon initialization and then saves the generated key
to decrypt eavesdropped messages.

Spoofing simulation can be run from the prompt by invoking:

[source,bash]
bin/spoofing_attack

which outputs something along the lines of:

[source,bash]
A has key: ["c26c3f32631b6eb395d90a63f835baccbdbc244cd400a15312bbfea15bffa93b"]
B has key: ["c26c3f32631b6eb395d90a63f835baccbdbc244cd400a15312bbfea15bffa93b"]
Spoofed C has key: ["c26c3f32631b6eb395d90a63f835baccbdbc244cd400a15312bbfea15bffa93b"]
B received: My credit card number is 1234567890123456
The attacker eavesdropped: My credit card number is 1234567890123456

== Possible Improvements
=== C Node Spoofing
A simple solution to the problem of spoofing **C** identity would be to make
use of **C** asymmetric keys during key agreement. +
In particular, in steps **1** and **4**, **A** and **B** could encrypt the
message latexmath:[[id_A, id_B, r_A]] using **C**'s public key
latexmath:[k_C']. On the other side, **C** would then decrypt received messages
using its private key latexmath:[k_C]. With this simple improvement, the only
way for an attacker to perform the same spoofing attack would be to steal
**C**'s private key, which is supposed to be an event with low probability of
success given the assumptions on which  asymmetric cryptography is based.

This solution is implemented in classes `AntispoofingA`, `AntispoofingB` and
`AntispoofingC`. The correctness of the implementation can be seen by launching
from the prompt:

[source,bash]
bin/antispoofing_agreement

To simulate the attack against this improved version, class
`SpoofedAntispoofingC` has been created. By launching

[source,bash]
bin/antispoofing_attack

it can be seen how the whole process generates an error when the malicious
**C** tries to decrypt the message from **A**'s step 1 without having the
correct private key.
